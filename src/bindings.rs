/* automatically generated by rust-bindgen */

#[doc = " @brief the H3Index fits within a 64-bit unsigned integer"]
pub type H3Index = u64;
#[doc = " @struct GeoCoord"]
#[doc = "@brief latitude/longitude in radians"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GeoCoord {
    #[doc = "< latitude in radians"]
    pub lat: f64,
    #[doc = "< longitude in radians"]
    pub lon: f64,
}
#[test]
fn bindgen_test_layout_GeoCoord() {
    assert_eq!(
        ::std::mem::size_of::<GeoCoord>(),
        16usize,
        concat!("Size of: ", stringify!(GeoCoord))
    );
    assert_eq!(
        ::std::mem::align_of::<GeoCoord>(),
        8usize,
        concat!("Alignment of ", stringify!(GeoCoord))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GeoCoord>())).lat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GeoCoord),
            "::",
            stringify!(lat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GeoCoord>())).lon as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GeoCoord),
            "::",
            stringify!(lon)
        )
    );
}
#[doc = " @struct GeoBoundary"]
#[doc = "@brief cell boundary in latitude/longitude"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GeoBoundary {
    #[doc = "< number of vertices"]
    pub numVerts: ::std::os::raw::c_int,
    #[doc = "< vertices in ccw order"]
    pub verts: [GeoCoord; 10usize],
}
#[test]
fn bindgen_test_layout_GeoBoundary() {
    assert_eq!(
        ::std::mem::size_of::<GeoBoundary>(),
        168usize,
        concat!("Size of: ", stringify!(GeoBoundary))
    );
    assert_eq!(
        ::std::mem::align_of::<GeoBoundary>(),
        8usize,
        concat!("Alignment of ", stringify!(GeoBoundary))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GeoBoundary>())).numVerts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GeoBoundary),
            "::",
            stringify!(numVerts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GeoBoundary>())).verts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GeoBoundary),
            "::",
            stringify!(verts)
        )
    );
}
#[doc = " @struct Geofence"]
#[doc = "  @brief similar to GeoBoundary, but requires more alloc work"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Geofence {
    pub numVerts: ::std::os::raw::c_int,
    pub verts: *mut GeoCoord,
}
#[test]
fn bindgen_test_layout_Geofence() {
    assert_eq!(
        ::std::mem::size_of::<Geofence>(),
        16usize,
        concat!("Size of: ", stringify!(Geofence))
    );
    assert_eq!(
        ::std::mem::align_of::<Geofence>(),
        8usize,
        concat!("Alignment of ", stringify!(Geofence))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Geofence>())).numVerts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Geofence),
            "::",
            stringify!(numVerts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Geofence>())).verts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Geofence),
            "::",
            stringify!(verts)
        )
    );
}
#[doc = " @struct GeoPolygon"]
#[doc = "  @brief Simplified core of GeoJSON Polygon coordinates definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GeoPolygon {
    #[doc = "< exterior boundary of the polygon"]
    pub geofence: Geofence,
    #[doc = "< number of elements in the array pointed to by holes"]
    pub numHoles: ::std::os::raw::c_int,
    #[doc = "< interior boundaries (holes) in the polygon"]
    pub holes: *mut Geofence,
}
#[test]
fn bindgen_test_layout_GeoPolygon() {
    assert_eq!(
        ::std::mem::size_of::<GeoPolygon>(),
        32usize,
        concat!("Size of: ", stringify!(GeoPolygon))
    );
    assert_eq!(
        ::std::mem::align_of::<GeoPolygon>(),
        8usize,
        concat!("Alignment of ", stringify!(GeoPolygon))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GeoPolygon>())).geofence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GeoPolygon),
            "::",
            stringify!(geofence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GeoPolygon>())).numHoles as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GeoPolygon),
            "::",
            stringify!(numHoles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GeoPolygon>())).holes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GeoPolygon),
            "::",
            stringify!(holes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LinkedGeoCoord {
    pub vertex: GeoCoord,
    pub next: *mut LinkedGeoCoord,
}
#[test]
fn bindgen_test_layout_LinkedGeoCoord() {
    assert_eq!(
        ::std::mem::size_of::<LinkedGeoCoord>(),
        24usize,
        concat!("Size of: ", stringify!(LinkedGeoCoord))
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedGeoCoord>(),
        8usize,
        concat!("Alignment of ", stringify!(LinkedGeoCoord))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LinkedGeoCoord>())).vertex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedGeoCoord),
            "::",
            stringify!(vertex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LinkedGeoCoord>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedGeoCoord),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LinkedGeoLoop {
    pub first: *mut LinkedGeoCoord,
    pub last: *mut LinkedGeoCoord,
    pub next: *mut LinkedGeoLoop,
}
#[test]
fn bindgen_test_layout_LinkedGeoLoop() {
    assert_eq!(
        ::std::mem::size_of::<LinkedGeoLoop>(),
        24usize,
        concat!("Size of: ", stringify!(LinkedGeoLoop))
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedGeoLoop>(),
        8usize,
        concat!("Alignment of ", stringify!(LinkedGeoLoop))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LinkedGeoLoop>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedGeoLoop),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LinkedGeoLoop>())).last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedGeoLoop),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LinkedGeoLoop>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedGeoLoop),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LinkedGeoPolygon {
    pub first: *mut LinkedGeoLoop,
    pub last: *mut LinkedGeoLoop,
    pub next: *mut LinkedGeoPolygon,
}
#[test]
fn bindgen_test_layout_LinkedGeoPolygon() {
    assert_eq!(
        ::std::mem::size_of::<LinkedGeoPolygon>(),
        24usize,
        concat!("Size of: ", stringify!(LinkedGeoPolygon))
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedGeoPolygon>(),
        8usize,
        concat!("Alignment of ", stringify!(LinkedGeoPolygon))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LinkedGeoPolygon>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedGeoPolygon),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LinkedGeoPolygon>())).last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedGeoPolygon),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LinkedGeoPolygon>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedGeoPolygon),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " @struct CoordIJ"]
#[doc = " @brief IJ hexagon coordinates"]
#[doc = ""]
#[doc = " Each axis is spaced 120 degrees apart."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoordIJ {
    #[doc = "< i component"]
    pub i: ::std::os::raw::c_int,
    #[doc = "< j component"]
    pub j: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CoordIJ() {
    assert_eq!(
        ::std::mem::size_of::<CoordIJ>(),
        8usize,
        concat!("Size of: ", stringify!(CoordIJ))
    );
    assert_eq!(
        ::std::mem::align_of::<CoordIJ>(),
        4usize,
        concat!("Alignment of ", stringify!(CoordIJ))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoordIJ>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CoordIJ),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoordIJ>())).j as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CoordIJ),
            "::",
            stringify!(j)
        )
    );
}
extern "C" {
    pub fn geoToH3(g: *const GeoCoord, res: ::std::os::raw::c_int) -> H3Index;
}
extern "C" {
    pub fn h3ToGeo(h3: H3Index, g: *mut GeoCoord);
}
extern "C" {
    pub fn h3ToGeoBoundary(h3: H3Index, gp: *mut GeoBoundary);
}
extern "C" {
    pub fn maxKringSize(k: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hexRange(
        origin: H3Index,
        k: ::std::os::raw::c_int,
        out: *mut H3Index,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hexRangeDistances(
        origin: H3Index,
        k: ::std::os::raw::c_int,
        out: *mut H3Index,
        distances: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hexRanges(
        h3Set: *mut H3Index,
        length: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        out: *mut H3Index,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kRing(origin: H3Index, k: ::std::os::raw::c_int, out: *mut H3Index);
}
extern "C" {
    pub fn kRingDistances(
        origin: H3Index,
        k: ::std::os::raw::c_int,
        out: *mut H3Index,
        distances: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hexRing(
        origin: H3Index,
        k: ::std::os::raw::c_int,
        out: *mut H3Index,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn maxPolyfillSize(
        geoPolygon: *const GeoPolygon,
        res: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn polyfill(geoPolygon: *const GeoPolygon, res: ::std::os::raw::c_int, out: *mut H3Index);
}
extern "C" {
    pub fn h3SetToLinkedGeo(
        h3Set: *const H3Index,
        numHexes: ::std::os::raw::c_int,
        out: *mut LinkedGeoPolygon,
    );
}
extern "C" {
    pub fn destroyLinkedPolygon(polygon: *mut LinkedGeoPolygon);
}
extern "C" {
    pub fn degsToRads(degrees: f64) -> f64;
}
extern "C" {
    pub fn radsToDegs(radians: f64) -> f64;
}
extern "C" {
    pub fn hexAreaKm2(res: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn hexAreaM2(res: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn edgeLengthKm(res: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn edgeLengthM(res: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn numHexagons(res: ::std::os::raw::c_int) -> i64;
}
extern "C" {
    pub fn res0IndexCount() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getRes0Indexes(out: *mut H3Index);
}
extern "C" {
    pub fn pentagonIndexCount() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getPentagonIndexes(res: ::std::os::raw::c_int, out: *mut H3Index);
}
extern "C" {
    pub fn h3GetResolution(h: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn h3GetBaseCell(h: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stringToH3(str: *const ::std::os::raw::c_char) -> H3Index;
}
extern "C" {
    pub fn h3ToString(h: H3Index, str: *mut ::std::os::raw::c_char, sz: usize);
}
extern "C" {
    pub fn h3IsValid(h: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn h3ToParent(h: H3Index, parentRes: ::std::os::raw::c_int) -> H3Index;
}
extern "C" {
    pub fn maxH3ToChildrenSize(
        h: H3Index,
        childRes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn h3ToChildren(h: H3Index, childRes: ::std::os::raw::c_int, children: *mut H3Index);
}
extern "C" {
    pub fn h3ToCenterChild(h: H3Index, childRes: ::std::os::raw::c_int) -> H3Index;
}
extern "C" {
    pub fn compact(
        h3Set: *const H3Index,
        compactedSet: *mut H3Index,
        numHexes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn maxUncompactSize(
        compactedSet: *const H3Index,
        numHexes: ::std::os::raw::c_int,
        res: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uncompact(
        compactedSet: *const H3Index,
        numHexes: ::std::os::raw::c_int,
        h3Set: *mut H3Index,
        maxHexes: ::std::os::raw::c_int,
        res: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn h3IsResClassIII(h: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn h3IsPentagon(h: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn maxFaceCount(h3: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn h3GetFaces(h3: H3Index, out: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn h3IndexesAreNeighbors(origin: H3Index, destination: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getH3UnidirectionalEdge(origin: H3Index, destination: H3Index) -> H3Index;
}
extern "C" {
    pub fn h3UnidirectionalEdgeIsValid(edge: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getOriginH3IndexFromUnidirectionalEdge(edge: H3Index) -> H3Index;
}
extern "C" {
    pub fn getDestinationH3IndexFromUnidirectionalEdge(edge: H3Index) -> H3Index;
}
extern "C" {
    pub fn getH3IndexesFromUnidirectionalEdge(edge: H3Index, originDestination: *mut H3Index);
}
extern "C" {
    pub fn getH3UnidirectionalEdgesFromHexagon(origin: H3Index, edges: *mut H3Index);
}
extern "C" {
    pub fn getH3UnidirectionalEdgeBoundary(edge: H3Index, gb: *mut GeoBoundary);
}
extern "C" {
    pub fn h3Distance(origin: H3Index, h3: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn h3LineSize(start: H3Index, end: H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn h3Line(start: H3Index, end: H3Index, out: *mut H3Index) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn experimentalH3ToLocalIj(
        origin: H3Index,
        h3: H3Index,
        out: *mut CoordIJ,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn experimentalLocalIjToH3(
        origin: H3Index,
        ij: *const CoordIJ,
        out: *mut H3Index,
    ) -> ::std::os::raw::c_int;
}
